<?xml version="1.0" encoding="UTF-8"?>

<archive asm="no">
    <comment>
        @defgroup uart HAL Uart Driver
        <br/>
        This document describes the characteristics of the UART module and
        how to use them via its Hardware Abstraction Layer API.
        The UART supports the following functions:
        <br/>- Supports Automatic Flow Control
        <br/>- Programmable receive and transmit FIFOs (16 bytes deep)
        <br/>- Supports low speed IrDA 1.0 SIR mode
        <br/>- DMA halabilities to allow fully automated data transfer
        <br/>- Wide selection of programmable interrupts to allow interrupt driven data
        transfer management
        <br/>- Up to 1.843 Mbits/s transfer rate.
        <br/>
        @par I/O Signals
        <br/>
        @image latex uart_io_sig.png "UART I/O Signals"
        @image html uart_io_sig.png "UART I/O Signals"
        <br/>
        <br/>
        @par
        A configuration structure hal_UartCfg allows to define the Uart behavior.
        The configurable items are:
        <br/>
        <br/>- \b Data \b Format \n
        The Uarts'driver supports either 7 bits data or 8 bits data with 1 or 2
        stopbits. If enabled, a parity check can be performed. The check can
        be configured to be even, odd, always 0 (space) or always one (mark).
        Those parameters apply for both the reception and transmission data.
        <br/>
        <br/>- \b FIFO \b Controls \n
        It can be configured to generate an interrupt when the
        reception FIFO is above a configurable threshold (Rx FIFO trigger) or
        when the emission FIFO is below a configurable threshold (Tx FIFO
        trigger).\n
        The available triggers for the reception FIFO are as follow :
        <br/>- #HAL_UART_RX_TRIG_1 -- One Data received in the
        Rx FIFO
        <br/>- #HAL_UART_RX_TRIG_QUARTER -- 1/4 of the Rx FIFO full
        <br/>- #HAL_UART_RX_TRIG_HALF -- 1/2 of the Rx FIFO full
        <br/>- #HAL_UART_RX_TRIG_NEARFULL -- Rx FIFO almost full
        .
        \n
        The available triggers for the transmission FIFO are as follow :
        <br/>- #HAL_UART_TX_TRIG_EMPTY -- Tx FIFO is empty
        <br/>- #HAL_UART_TX_TRIG_QUARTER -- Less than 1/4 of the Tx
        FIFO left to send
        <br/>- #HAL_UART_TX_TRIG_HALF -- Less than 1/2 of the Tx
        FIFO left to send
        <br/>- #HAL_UART_TX_TRIG_3QUARTER -- Less than 3/4 of the Tx
        FIFO left to send
        .
        \n
        <br/>- \b Hardware \b Flow \b Control \n
        The hardware flow control modes make it possible to avoid FIFO
        overrun or underrun and are the only way to guarantee a reliable
        transfer, without any loss of bytes.\n
        When the hardware flow control is enabled:
        <br/>- The emission will stop as soon as the CTS_L line is held high
        by the receiving device
        <br/>- When the Rx FIFO level reaches the selected level (parametrable
        as a number of byts) the RTS_L line is held high by the Uart hardware to
        tell the emitting device that it should stop emitting.
        .
        \n
        It is /b MANDATORY to use the AFC. \n
        <br/>
        <br/>- @b IrDA @b Mode \n
        IrDA 1.0 SIR mode is available and can be activated when the user
        opens a Uart. When SIR mode is enabled, serial data is transmitted and
        received on the Uart_Tx and Uart_Rx ports, respectively. IrDA 1.0 SIR
        mode supports bi-directional data communications with remote devices
        using infrared radiation as a transmission medium. IrDA 1.0 SIR mode
        specifies a maximum baud rate of 115.2 KBaud.\n\n
        Each data character is sent serially, beginning with a start bit,
        followed by 8 data bits, and ending with at least one stop bit.
        Transmitting a single infrared pulse signals a logic zero, while a
        logic one is represented by not sending a pulse. The width of each
        pulse is 3/16ths of a normal serial bit time.\n\n
        Thus, each new character begins with an infrared pulse for the start
        bit. However, received data is inverted from transmitted data due to
        the fact that the infrared pulses energizing the photo transistor
        (base of the IrDA receiver) pull its output low. This inverted
        transistor output is then fed to the Uart_Rx port, which then has a
        correct UART polarity. See the following figure for more details.
        @image html uart_irda_sir_data_format.png "IrDA SIR Data Format"
        @image latex uart_irda_sir_data_format.png "IrDA SIR Data Format"
        \n
        The UART module operation when in IrDA SIR mode is similar to
        what it is when the mode is disabled, with one exception: data
        transfers can only occur in half-duplex fashion. This is due to the
        IrDA SIR physical layer which specifies a minimum delay of 10ms
        between transmission and reception. This 10ms delay must be generated
        by software.
        <br/>
        <br/>- @b Baud @b Rate @b Selection \n
        UARTs are able to run at a wide selection of baud rates. This
        must be configured at the UART opening. The available baud rates are:\n
        <br/>- 2.4 KBaud (Serial and IrDA)
        <br/>- 4.8 KBaud (Serial and IrDA)
        <br/>- 9.6 KBaud (Serial and IrDA)
        <br/>- 14.4 KBaud (Serial and IrDA)
        <br/>- 19.2 KBaud (Serial and IrDA)
        <br/>- 28.8 KBaud (Serial and IrDA)
        <br/>- 33.6 KBaud (Serial and IrDA)
        <br/>- 38.4 KBaud (Serial and IrDA)
        <br/>- 57.6 KBaud (Serial and IrDA)
        <br/>- 115.2 KBaud (Serial and IrDA)
        <br/>- 230.4 KBaud (Available only in serial mode)
        <br/>- 460.8 KBaud (Available only in serial mode)
        <br/>- 921.6 KBaud (Available only in serial mode)
        <br/>- 1843.2 KBaud (Available only in serial mode)
        .
        \n
        Note that the highest baudrates will require the system to run at a
        high enough frequency to allow for a precise enough sampling clock
        generation.
        <br/>
        <br/>- @b Transfer @b Mode \n
        To allow for an easy use of the Uart module, a non blocking
        Hardware Abstraction Layer interface is provided. Each transfer
        direction (Send/Receive) can be configured as :
        <br/>- @b Direct @b polling: \n
        The application sends/receives the data directly to/from the
        hardware module. The number of bytes actually sent/received is
        returned. No Irqs is generated.
        \n
        <br/>- @b Direct @b IRQ: \n
        The application sends/receives the data directly to/from the
        hardware module. The number of bytes actually sent/received is
        returned. An irq can be generated when the Tx/Rx FIFO reaches the
        pre-programmed level.
        \n
        <br/>- @b DMA @b polling: \n
        The application sends/receives the data through a DMA to the
        hardware module.
        \n
        When no DMA channel is available, the function returns 0. No
        byte is sent.
        \n
        When a DMA resource is available, the function returns the number
        of bytes to send. They will all be sent.
        \n
        A function allows to check if the previous DMA transfer is
        finished. No new DMA transfer for the same Uart and in the same
        direction is allowed until the previous transfer is finished.
        \n
        <br/>- @b DMA @b IRQ: \n
        The application sends/receives the data through a DMA to the
        hardware module.
        \n
        When no DMA channel is available, the function returns 0. No byte
        is sent.
        \n
        When a DMA resource is available, the function returns the number
        of bytes to send. They will all be sent. An Irq is generated when
        the current transfer is finished. No new DMA transfer for the same
        Uart and in the same direction is allowed until the previous
        transfer is finished.
        .
        \n
        If you use the Rx Uart (to get some data from the Uart) in DMA mode,
        you will have to call the #hal_SysInvalidateCache function to
        invalidate the cache on your reception buffer. Please refer to the
        Application Note 0019 "Cache and DMA Modules"for more details.
        <br/>
        @par Interrupt Masks
        The UART can generate interruptions for several reasons.
        Cf the specific functions of the driver for details.
        <br/>
        @par
        When the user interrupt service function is called, in case of a line
        error interrupt (\c rxLineErr), the status passed to this
        function will contain the status of the interrupt (as usual) and
        the status of the error in a structure of type #HAL_UART_ERROR_STATUS_T.
        <br/>
        @par Configuration Structure
        #HAL_UART_CFG_T is used to open the UART port with the desired parameters.
        <br/>
        @{
        <br/>
        <br/>
           
    </comment>


  <include load="no" file="cs_types.h"  /> 
  <include load="no" file="hal_error.h" /> 

  <enum name='HAL_UART_DATA_BITS'>
    <comment>UART data length</comment>

    <entry name='HAL_UART_7_DATA_BITS'>
      <comment>Data is 7 bits</comment>
    </entry>
    <entry name='HAL_UART_8_DATA_BITS'>
      <comment>Data is 8 bits</comment>
    </entry>
    <entry name='HAL_UART_DATA_BITS_QTY'></entry>
  </enum>

  <enum name='HAL_UART_STOP_BITS_QTY'>
    <comment>Number of stop bits</comment>

    <entry name='HAL_UART_1_STOP_BIT'>
      <comment>There is 1 stop bit</comment>
    </entry>
    <entry name='HAL_UART_2_STOP_BITS'>
      <comment>There are 2 stop bits</comment>
    </entry>
    <entry name='HAL_UART_STOP_BITS_QTY'></entry>
  </enum>

  <enum name='HAL_UART_PARITY_CFG'>
    <comment>Data parity control selection  If enabled, a parity check can be performed</comment>

    <entry name='HAL_UART_NO_PARITY'>
      <comment>No parity check</comment>
    </entry>
    <entry name='HAL_UART_ODD_PARITY'>
      <comment>Parity check is odd</comment>
    </entry>
    <entry name='HAL_UART_EVEN_PARITY'>
      <comment>Parity check is even</comment>
    </entry>
    <entry name='HAL_UART_SPACE_PARITY'>
      <comment>Parity check is always 0 (space)</comment>
    </entry>
    <entry name='HAL_UART_MARK_PARITY'>
      <comment>Parity check is always 1 (mark)</comment>
    </entry>
    <entry name='HAL_UART_PARITY_QTY'></entry>
  </enum>

  <enum name='HAL_UART_RX_TRIGGER_CFG'>
    <comment>Reception FIFO trigger (or treshold) level  The Uarts can be configured to generate an interrupt when the  reception FIFO is above a configurable threshold (Rx FIFO trigger</comment>

    <entry name='HAL_UART_RX_TRIG_1' value='0'>
      <comment>One data received in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_RX_TRIG_QUARTER' value='7'>
      <comment>1/4 of the Rx FIFO is full</comment>
    </entry>
    <entry name='HAL_UART_RX_TRIG_HALF' value='15'>
      <comment>1/2 of the Rx FIFO is full</comment>
    </entry>
    <entry name='HAL_UART_RX_TRIG_3QUARTER' value='23'>
      <comment>3/4 of the Rx FIFO is full</comment>
    </entry>
    <entry name='HAL_UART_RX_TRIG_NEARFULL' value='30'>
      <comment>Rx FIFO is almost full</comment>
    </entry>
  </enum>

  <enum name='HAL_UART_TX_TRIGGER_CFG'>
    <comment>Tranmission FIFO trigger (or treshold) level.  The Uarts can be configured to generate an interrupt when the  emission FIFO is below a configurable threshold (Tx FIFO trigger</comment>

    <entry name='HAL_UART_TX_TRIG_EMPTY' value='0'>
      <comment>Tx FIFO empty</comment>
    </entry>
    <entry name='HAL_UART_TX_TRIG_QUARTER' value='3'>
      <comment>Less than 1/4 of the Tx FIFO left to send</comment>
    </entry>
    <entry name='HAL_UART_TX_TRIG_HALF' value='7'>
      <comment>Less than 1/2 of the Tx FIFO left to send</comment>
    </entry>
    <entry name='HAL_UART_TX_TRIG_3QUARTER' value='11'>
      <comment>Less than 3/4 of the Tx FIFO left to send</comment>
    </entry>
  </enum>

  <enum name='HAL_UART_AFC_MODE'>
    <comment>Auto Flow Control.  Controls the Rx Fifo level at which the Uart_RTS Auto Flow Control will be  set inactive high (see UART Operation for more details on AFC). The  Uart_RTS Auto Flow Control will be set inactive high when quantity of  data in Rx Fifo &amp;gt; AFC Level</comment>

    <entry name='HAL_UART_AFC_MODE_RX_TRIG_1' value='0'>
      <comment>RTS inactive with 1 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_2' value='1'>
      <comment>RTS inactive with 2 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_3' value='2'>
      <comment>RTS inactive with 3 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_4' value='3'>
      <comment>RTS inactive with 4 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_5' value='4'>
      <comment>RTS inactive with 5 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_6' value='5'>
      <comment>RTS inactive with 6 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_7' value='6'>
      <comment>RTS inactive with 7 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_8' value='7'>
      <comment>RTS inactive with 8 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_9' value='8'>
      <comment>RTS inactive with 9 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_10' value='9'>
      <comment>RTS inactive with 10 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_11' value='10'>
      <comment>RTS inactive with 11 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_12' value='11'>
      <comment>RTS inactive with 12 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_13' value='12'>
      <comment>RTS inactive with 13 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_14' value='13'>
      <comment>RTS inactive with 14 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_15' value='14'>
      <comment>RTS inactive with 15 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_RX_TRIG_16' value='15'>
      <comment>RTS inactive with 16 data in the Rx FIFO</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_DISABLE' value='16'>
      <comment>Hardware flow control is disabled. \n  &amp;lt;B&amp;gt; NEVER USE THIS MODE &amp;lt;/B&amp;gt;</comment>
    </entry>
    <entry name='HAL_UART_AFC_MODE_QTY'></entry>
    <entry name='HAL_UART_AFC_LOOP_BACK' value='32'>
      <comment>AFC mode is loopback \n  When set, data on the Uart_Tx line is held high, while the serial output  is looped back to the serial input line, internally.</comment>
    </entry>
  </enum>

  <enum name='HAL_UART_IRDA_MODE'>
    <comment>IrDA protocole enabling  IrDA SIR mode is available, and can be activated when the user open the Uart</comment>

    <entry name='HAL_UART_IRDA_MODE_DISABLE'>
      <comment>IrDA mode disabled</comment>
    </entry>
    <entry name='HAL_UART_IRDA_MODE_ENABLE'>
      <comment>IrDA mode enabled</comment>
    </entry>
    <entry name='HAL_UART_IRDA_MODE_QTY'></entry>
  </enum>

  <enum name='HAL_UART_BAUD_RATE'>
    <comment>Baudrate available with the modifiable system clock  UARTs are able to run at a wide selection of baud rates. This must  be configured at the UART opening</comment>

    <entry name='HAL_UART_BAUD_RATE_2400' value='2400'>
      <comment>2.4 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_4800' value='4800'>
      <comment>4.8 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_9600' value='9600'>
      <comment>9.6 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_14400' value='14400'>
      <comment>14.4 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_19200' value='19200'>
      <comment>19.2 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_28800' value='28800'>
      <comment>28.8 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_33600' value='33600'>
      <comment>33.6 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_38400' value='38400'>
      <comment>38.4 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_57600' value='57600'>
      <comment>57.6 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_115200' value='115200'>
      <comment>115.2 KBaud (Serial and IrDA)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_230400' value='230400'>
      <comment>230.4 KBaud (Available only in serial mode)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_460800' value='460800'>
      <comment>460.8 KBaud (Available only in serial mode)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_921600' value='921600'>
      <comment>921.6 KBaud (Available only in serial mode)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_1843200' value='1843200'>
      <comment>1843.2 KBaud (Available only in serial mode)</comment>
    </entry>
    <entry name='HAL_UART_BAUD_RATE_QTY'></entry>
  </enum>

  <enum name='HAL_UART_TRANSFERT_MODE'>
    <comment>Data transfert mode: via DMA or direct.  To allow for an easy use of the Uart modules, a non blocking hardware  abstraction layer interface is provided</comment>

    <entry name='HAL_UART_TRANSFERT_MODE_DIRECT_POLLING' value='0'>
      <comment>Direct polling: The application sends/receives the data directly to/from  the hardware module. The number of bytes actually sent/received is  returned. No IRQ is generated.</comment>
    </entry>
    <entry name='HAL_UART_TRANSFERT_MODE_DIRECT_IRQ' value='1'>
      <comment>Direct Irq: The application sends/receives the data directly to/from  the hardware module. The number of bytes actually sent/received is  returned.An irq can be generated when the Tx/Rx FIFO reaches the  pre-programmed level.</comment>
    </entry>
    <entry name='HAL_UART_TRANSFERT_MODE_DMA_POLLING' value='2'>
      <comment>DMA polling: The application sends/receives the data through a DMA to  the hardware module. When no DMA channel is available, the function  returns 0. No byte is sent. When a DMA resource is available, the  function returns the number of bytes to send. They will all be sent. A  function allows to check if the previous DMA transfer is finished. No  new DMA transfer for the same Uart and in the same direction is  allowed until the previous transfer is finished.</comment>
    </entry>
    <entry name='HAL_UART_TRANSFERT_MODE_DMA_IRQ' value='3'>
      <comment>The application sends/receives the data through a DMA to the hardware  module. When no DMA channel is available, the function returns 0. No  byte is sent. When a DMA resource is available, the function returns  the number of bytes to send. They will all be sent. An Irq is generated  when the current transfer is finished. No new DMA transfer for the  same Uart and in the same direction is allowed until the previous  transfer is finished.</comment>
    </entry>
    <entry name='HAL_UART_TRANSFERT_MODE_OFF' value='4'>
      <comment>The transfert is off.</comment>
    </entry>
    <entry name='HAL_UART_TRANSFERT_MODE_QTY'></entry>
  </enum>

  <typedef name='HAL_UART_CFG'>
    <comment>UART Configuration Structure  This structure defines the Uart behavior</comment>

    <instance name='data' type='HAL_UART_DATA_BITS'>
      <comment>Data format</comment>
    </instance>
    <instance name='stop' type='HAL_UART_STOP_BITS_QTY'>
      <comment>Number of stop bits</comment>
    </instance>
    <instance name='parity' type='HAL_UART_PARITY_CFG'>
      <comment>Parity check</comment>
    </instance>
    <instance name='rx_trigger' type='HAL_UART_RX_TRIGGER_CFG'>
      <comment>Trigger for the Rx FIFO</comment>
    </instance>
    <instance name='tx_trigger' type='HAL_UART_TX_TRIGGER_CFG'>
      <comment>Trigger for the Tx FIFO</comment>
    </instance>
    <instance name='afc' type='HAL_UART_AFC_MODE'>
      <comment>Hardware Flow control</comment>
    </instance>
    <instance name='irda' type='HAL_UART_IRDA_MODE'>
      <comment>IrDA mode</comment>
    </instance>
    <instance name='rate' type='HAL_UART_BAUD_RATE'>
      <comment>Baud Rate</comment>
    </instance>
    <instance name='rx_mode' type='HAL_UART_TRANSFERT_MODE'>
      <comment>Reception transfer mode</comment>
    </instance>
    <instance name='tx_mode' type='HAL_UART_TRANSFERT_MODE'>
      <comment>Transmission transfer mode</comment>
    </instance>
  </typedef>

  <alias name='HAL_UART_IRQ_STATUS'>

    <uint32 name='unused'>
      <comment>Uart Irq cause structure. This structure is used to set the masks and get the  IRQ status of the uarts.</comment>

      <bits name='txModemStatus' pos='0'> 
        <comment>Clear to send signal detected.</comment>
      </bits>
      <bits name='rxDataAvailable' pos='1'>   
        <comment>Rx FIFO at or upper a threshold level (current level &amp;gt;= Rx FIFO trigger  level) trigs an interrupt. This level is programmed when the UART is opened.</comment>
      </bits>
      <bits name='txDataNeeded' pos='2'>  
        <comment>Tx FIFO at or below a threshold level (current level &amp;lt;= Tx FIFO trigger  level) trigs an interrupt. This level is programmed when the UART is opened.</comment>
      </bits>
      <bits name='rxTimeout' pos='3'> 
        <comment>It there is no character in or out of the Rx FIFO during the last 4  character times and if there is at least 1 character in this FIFO during  this time, the an interrupt is trigged.</comment>
      </bits>
      <bits name='rxLineErr' pos='4'> 
        <comment>This interrupt is generated when a Tx Overflow, Rx Overflow, Parity Error,  Framing Error or Break Interrupt occurs.</comment>
      </bits>
      <bits name='txDmaDone' pos='5'> 
        <comment>This interrupt is generated when the DMA transmission is finished. The  transmission mode is set at the UART opening.</comment>
      </bits>
      <bits name='rxDmaDone' pos='6'> 
        <comment>This interrupt is generated when the DMA reception is finished. The  reception mode is set at the UART opening.</comment>
      </bits>
      <bits name='rxDmaTimeout' pos='7'>  
        <comment>This interrupt is generated when a DMA reception time-out.</comment>
      </bits>
      <bits name='DTR_Rise' pos='8'>  
        <comment>This interrupt is generated when a rising edge is detected on the UART_DTR signal.</comment>
      </bits>
      <bits name='DTR_Fall' pos='9'>  
        <comment>This interrupt is generated when a falling edge is detected on the UART_DTR signal.</comment>
      </bits>
    </uint32>
  </alias>

  <alias name='HAL_UART_ERROR_STATUS'>

    <uint32 name='unused'>
      <comment>This structures reflects the detailed status of the "LINE  ERROR" IRQ, ie: the error status.</comment>

      <bits name=' ' pos='0:15'>    
        <comment>These bits are not error stuff</comment>
      </bits>
      <bits name='rxOvflErr' pos='16'> 
        <comment>This bit indicates that the UART  received a new character when the Rx FIFO was already full. The new  character is discarded.</comment>
      </bits>
      <bits name='txOvflErr' pos='17'> 
        <comment>This bit indicates that the user tried to write a character on the  Tx FIFO while it was already full. The written data will not be kept.</comment>
      </bits>
      <bits name='rxParityErr' pos='18'>   
        <comment>This bit is set if the parity is enabled and a parity error occurred  in the received data.</comment>
      </bits>
      <bits name='rxFramingErr' pos='19'>  
        <comment>This bit is set whenever a framing error occurred. A framing error  occurs when the receiver does not detect a valid STOP bit in the  received data.</comment>
      </bits>
      <bits name='rxBreakInt' pos='20'>    
        <comment>Set whenever the serial input is held in a logic 0 state for longer  than the length of x bits, where x is programmable.  A null word will be write in the Rx Fifo.</comment>
      </bits>
    </uint32>
  </alias>

  <cjoker>
// ============================================================================
// TYPES
// ============================================================================

typedef VOID (*HAL_UART_IRQ_HANDLER_T)(HAL_UART_IRQ_STATUS_T, HAL_UART_ERROR_STATUS_T);

/// Uart 0 is the trace uart and is unavailable for this driver
/// The numbering starts at 1 for consistency.
/// The HAL_UART_QTY value is defined as the number of UARTS
/// avalaible for the chip on which the driver is running, and
/// can therefore be used for consistency checks
typedef enum {
    HAL_UART_1                                  = 0x00000001,
    HAL_UART_2                                  = 0x00000002,
    HAL_UART_QTY                                = CHIP_STD_UART_QTY+1
} HAL_UART_ID_T;   


// ============================================================================
// FUNCTIONS
// ============================================================================

// ============================================================================
// hal_UartBreakIntWakeup
// ----------------------------------------------------------------------------
/// This function configures whether the system can be waked up 
/// by Uart break interrupt.
/// It must be configured before calling hal_UartOpen and hal_UartClose
/// to take effect.
///
/// @param id Identifier of the UART for which the function is called.
/// @param on TRUE to enable breakIntWakeup mode, FALSE otherwise.
// ============================================================================
PUBLIC VOID hal_UartBreakIntWakeup(HAL_UART_ID_T id, BOOL on);


// ============================================================================
// hal_UartIrqEnableBreakInt
// ----------------------------------------------------------------------------
/// This function enables or disables UART break IRQ.
///
/// @param id Identifier of the UART for which the function is called.
/// @param enable TRUE to enable break IRQ, FALSE otherwise.
// ============================================================================
PUBLIC VOID hal_UartIrqEnableBreakInt(HAL_UART_ID_T id, BOOL enable);


// ============================================================================
// hal_UartOpen
// ----------------------------------------------------------------------------
/// This function enables the Uart in the mode defined by \c uartCfg
///
/// This function requests a resource of #HAL_SYS_FREQ_26M only for a pll to be on.
///
/// @param id Identifier of the UART for which the function is called.
/// @param uartCfg Uart configuration structure
// ============================================================================
PUBLIC VOID hal_UartOpen(HAL_UART_ID_T id, CONST HAL_UART_CFG_T* uartCfg);


// ============================================================================
// hal_UartClose
// ----------------------------------------------------------------------------
/// This function closes the selected UART
///
/// This function release the resource to #HAL_SYS_FREQ_32K.
///
/// @param id Identifier of the UART for which the function is called.
// ============================================================================
PUBLIC VOID hal_UartClose(HAL_UART_ID_T id);


// ============================================================================
// hal_UartAllowSleep
// ----------------------------------------------------------------------------
/// That function is called to signify that the uart needs allow or not
/// the system to go into lowpower.
/// @param id Identifier of the UART for which the function is called.
/// @param allow If \c TRUE, the system is allowed to go into lowpower mode. \n
/// If \c FALSE, this prevents the system from entering in
/// lowpower mode.
// ============================================================================
PUBLIC VOID hal_UartAllowSleep(HAL_UART_ID_T id, BOOL allow);


// ============================================================================
// hal_UartSendData
// ----------------------------------------------------------------------------
/// This functions sends \c length bytes of data starting from the address
/// \c data. The number returned is the number of bytes actually sent. In
/// DMA mode, this function returns 0 when no DMA channel is available.
/// Otherwise, it returns \c length.
///
/// @param id Identifier of the UART for which the function is called.
/// @param data Pointer on the buffer of data to send.
/// @param length Number of bytes to send.
/// @return Number of sent bytes or 0 if no DMA channel is available in case of
/// a DMA transfer.
// ============================================================================
PUBLIC UINT32 hal_UartSendData(HAL_UART_ID_T id, CONST UINT8 *data, UINT32 length);


// ============================================================================
// hal_UartTxDmaDone
// ----------------------------------------------------------------------------
/// This function checks if the DMA transmission is finished.
/// Before sending new data in DMA mode, the previous DMA transfer must be
/// finished, hence the use of this function for polling.
///
/// Note that the DMA transfer can be finished with an unempty Tx FIFO. Before
/// shutting down the Uart, one must check that the uart FIFO is empty and that
/// the last byte has been completely sent by using #hal_UartTxFinished. It
/// is not necessary to check the emptiness of the Tx FIFO to start a new DMA
/// transfer. A new DMA transfer is possible once the previous DMA transfer
/// is over (And even is the Tx FIFO is not empty).
///
/// @param id Identifier of the UART for which the function is called.
/// @return \c TRUE if the last DMA transfer is finished. \c NO otherwise.
// ============================================================================
PUBLIC BOOL hal_UartTxDmaDone(HAL_UART_ID_T id);


// ============================================================================
// hal_UartTxFinished
// ----------------------------------------------------------------------------
/// This functions checks if the data transfer is completely finished before
/// closing.
/// This function returns \c TRUE when the transmit FIFO is empty and when the
/// last byte is completely sent. It should be called before closing the Uart
/// if the last bytes of the transfer are important.
///
/// This function should not be called between transfers, in direct or DMA mode.
/// The \link #hal_UartTxFifoAvailable FIFO available \endlink for direct
/// mode and the \link #hal_UartTxDmaDone DMA done indication \endlink for
/// DMA allow for a more optimized transmission.
///
/// @param id Identifier of the UART for which the function is called.
/// @return \c TRUE if the Tx FIFO is empty. \c NO otherwise
// ============================================================================
PUBLIC BOOL hal_UartTxFinished(HAL_UART_ID_T id);


// ============================================================================
// hal_UartGetData
// ----------------------------------------------------------------------------
/// This function gets \c length bytes from the Uart and stores them starting
/// from the address \c dest_address. The number returned is the number of bytes
/// actually received.
/// In DMA mode, this function returns 0 when no DMA channel is available. It
/// returns length otherwise.
/// If you use the Rx Uart (to get some data from the Uart) in DMA mode, you
/// will have to call the #hal_SysInvalidateCache function to invalidate the
/// cache on your reception buffer.
///
/// @param id Identifier of the UART for which the function is called.
/// @param destAddress Pointer to a buffer to store the received data
/// @param length Number of byte to receive
/// @return The number of actually received bytes, or 0 when no DMA channel is
/// available in case of a DMA transfer.
// ============================================================================
PUBLIC UINT32 hal_UartGetData(HAL_UART_ID_T id, UINT8* destAddress, UINT32 length);


// ============================================================================
// hal_UartRxFifoLevel
// ----------------------------------------------------------------------------
/// This function returns the number of bytes in the Rx FIFO
///
/// @param id Identifier of the UART for which the function is called.
/// @returns The number of bytes in the Rx FIFO
// ============================================================================
PUBLIC UINT8 hal_UartRxFifoLevel(HAL_UART_ID_T id);


// ============================================================================
// hal_UartRxDmaDone
// ----------------------------------------------------------------------------
/// Check if the reception is finished.
///
/// Before being able to receive new data in DMA mode, the previous transfer
/// must be finished, hence the use of this function for polling.
///
/// @param id Identifier of the UART for which the function is called.
/// @returns \c TRUE if the last DMA transfer is finished. \c NO otherwise
// ============================================================================
PUBLIC BOOL hal_UartRxDmaDone(HAL_UART_ID_T id);


// ============================================================================
// hal_UartRxDmaStop
// ----------------------------------------------------------------------------
/// This functions terminates the current Rx transfer and releases the
/// current Rx IFC DMA channel used by identified UART.
/// If the IFC channel fifo is not empty the transfer is not terminated.
/// This is useful when the DMA Rx Timeout rises.
///
/// @param id Identifier of the UART for which the function is called.
/// @return \c TRUE if the transfer has been released or if the current
/// UART doesn't have an IFC DMA channel attributed. \c FALSE if the
/// transfer cannot be released, i.e. the IFC DMA channel fifo is not empty.  
// ============================================================================
PUBLIC BOOL hal_UartRxDmaStop(HAL_UART_ID_T id);


// ============================================================================
// hal_UartRxDmaLevel
// ----------------------------------------------------------------------------
/// This function returns the number of free room remaining in the IFC DMA Rx
/// buffer. It can be useful to know when you can get data from the buffer. 
/// 
/// @param id Identifier of the UART for which the function is called.
/// @return Number of data (in bytes) remaining in the DMA buffer.
// ============================================================================
PUBLIC UINT32 hal_UartRxDmaLevel(HAL_UART_ID_T id);


// ============================================================================
// hal_UartRxDmaFifoEmpty
// ----------------------------------------------------------------------------
/// This function returns \c TRUE when the fifo of the DMA is empty.
///
/// @param id Identifier of the UART for which the function is called.
/// @returns \c TRUE when the fifo of the DMA is empty.
// ============================================================================
PUBLIC BOOL hal_UartRxDmaFifoEmpty(HAL_UART_ID_T id);


// ============================================================================
// hal_UartRxDmaPurgeFifo
// ----------------------------------------------------------------------------
/// Sends all the remaining data in the IFC fifo to the RAM buffer.
/// 
/// After the IFC DMA channel has been purged, it is NOT released.
/// After calling this function, the software should wait for the
/// actual end of the purging the fifo, by calling the function
/// hal_UartRxDmaFifoEmpty().
/// After the IFC DMA channel has been purged (or is being purged),
/// the data from the UART will not be read by the IFC DMA channel
/// anymore. This means that after calling this function, the user must
/// stop the current transfer and restart a new transfer.
///
/// @param id Identifier of the UART for which the function is called.
// ============================================================================
PUBLIC VOID hal_UartRxDmaPurgeFifo(HAL_UART_ID_T id);


// ============================================================================
// hal_UartSetRi
// ----------------------------------------------------------------------------
/// Sets the RI bit to the value given as a parameter
///
/// @param id Identifier of the UART for which the function is called.
/// @param value If \c TRUE, the RI bit is set.
/// If \c FALSE, the RI bit is cleared.
// ============================================================================
PUBLIC VOID hal_UartSetRi(HAL_UART_ID_T id, BOOL value);


// ============================================================================
// hal_UartSetDsr
// ----------------------------------------------------------------------------
/// Sets the DSR bit to the value given as a parameter
///
/// @param id Identifier of the UART for which the function is called.
/// @param value If \c TRUE, the DSR bit is set.
/// If \c FALSE, the DSR bit is cleared.
// ============================================================================
PUBLIC VOID hal_UartSetDsr(HAL_UART_ID_T id, BOOL value);


// ============================================================================
// hal_UartSetDcd
// ----------------------------------------------------------------------------
/// Sets the DCD bit to the value given as a parameter
///
/// @param id Identifier of the UART for which the function is called.
/// @param value If \c TRUE, the DCD bit is set.
/// If \c FALSE, the DCD bit is cleared.
// ============================================================================
PUBLIC VOID hal_UartSetDcd(HAL_UART_ID_T id, BOOL value);


// ============================================================================
// hal_UartGetDtr
// ----------------------------------------------------------------------------
/// Read the current value of the DTR line
/// @param id Identifier of the UART for which the function is called.
/// @return The current value of the DTR line. (\c TRUE or \c FALSE)
// ============================================================================
PUBLIC BOOL hal_UartGetDtr(HAL_UART_ID_T id);


// ============================================================================
// hal_UartSetBreak
// ----------------------------------------------------------------------------
/// Enable or disable the break (hold the Tx line low).
///
/// With this function, it is possible to generate a break: when the booLean
/// parameter \c enable is set to \c TRUE, the Uart_Tx line is held low, thus
/// generating a break on the line. It is held low until this function is
/// called again with the parameter \c enable set to \c FALSE.
///
/// @param id Identifier of the UART for which the function is called.
/// @param enable When set to \c TRUE, enables a break. When set to \c FALSE,
/// disables a break.
// ============================================================================
PUBLIC VOID hal_UartSetBreak(HAL_UART_ID_T id, BOOL enable);


// ============================================================================
// hal_UartTxFifoAvailable
// ----------------------------------------------------------------------------
/// This function returns the number of bytes available in the TX FIFO
///
/// @param id Identifier of the UART for which the function is called.
/// @return The number of available bytes in the TX FIFO.
// ============================================================================
PUBLIC UINT8 hal_UartTxFifoAvailable(HAL_UART_ID_T id);


// ============================================================================
// hal_UartGetErrorStatus
// ----------------------------------------------------------------------------
/// Gives the status of the UART.
/// This function returns the line error status. The \c UINT16 value returned
/// is a bitfield containing the errors detected during the transfer. The
/// errors can be: #HAL_ERR_UART_RX_OVERFLOW, #HAL_ERR_UART_TX_OVERFLOW,
/// #HAL_ERR_UART_PARITY, #HAL_ERR_UART_FRAMING, or #HAL_ERR_UART_BREAK_INT.
///
/// @param id Identifier of the UART for which the function is called.
/// @return The line error status
// ============================================================================
PUBLIC HAL_ERR_T hal_UartGetErrorStatus(HAL_UART_ID_T id);


// ============================================================================
// hal_UartClearErrorStatus
// ----------------------------------------------------------------------------
/// This function clears all the line error status. The error status is cleared
/// automatically by the interrupt dispatcher code, but if you do not use the
/// interrupt, the error status is not cleared. This means that if you check
/// the error status manually (by polling it with the #hal_UartGetErrorStatus
/// function), you'll need to call the #hal_UartClearErrorStatus function to
/// clear it, manually.
///
/// @param id Identifier of the UART for which the function is called.
// ============================================================================
PUBLIC VOID hal_UartClearErrorStatus(HAL_UART_ID_T id);


// ============================================================================
// hal_UartFifoFlush
// ----------------------------------------------------------------------------
/// This function resets the reception and the transmission FIFOs. All bytes
/// that are waiting to be sent in the Tx FIFO and that have been received,
/// waiting to be read in the Rx FIFO, will be removed.
///
/// @param id Identifier of the UART for which the function is called.
// ============================================================================
PUBLIC VOID hal_UartFifoFlush(HAL_UART_ID_T id);


// ============================================================================
// hal_UartSetRts
// ----------------------------------------------------------------------------
/// This function controls the RTS line of the UART. When the function is
/// called with a \c ready parameter set to \c FALSE, that means that the CPU
/// is not ready to handle the data of the UART. The remote device will stop
/// sending data to the UART.
///
/// To resume the data transfer (i.e. to let the remote device send data to the
/// UART again), call this function with a \c ready parameter set to \c TRUE.
///
/// If the hardware flow control is enabled, the RTS line will be controlled as
/// follows: RTS Line Ready = CPU Ready AND UART Hardware Flow Control Ready.
/// It means that if the UART or the CPU is not ready, the RTS line will ask
/// the remote device to stop sending data.
///
/// When the flow control is handled by the #hal_UartSetRts function, it is
/// called software flow control. The software flow control can be used in
/// parallel to the hardware flow control. Please refer to previous chapters for
/// details about @link #HAL_UART_AFC_MODE_T hardware flow control @endlink.
///
/// @param id Identifier of the UART for which the function is called.
/// @param ready Ready to receive data from the remote
/// device (&amp;amp;lt;CODE&amp;amp;gt; ready = TRUE &amp;amp;lt;/CODE&amp;amp;gt;) or not (&amp;amp;lt;CODE&amp;amp;gt; ready = FALSE &amp;amp;lt;/CODE&amp;amp;gt;)
// ============================================================================
PUBLIC VOID hal_UartSetRts(HAL_UART_ID_T id, BOOL ready);


// ============================================================================
// hal_UartGetCts
// ----------------------------------------------------------------------------
/// This function returns the value of the CTS line of the UART. When the
/// function returns \c TRUE, that means that the remote peripheral is
/// ready to receive data on its serial interface. The UART should stop sending
/// data.
///
/// If the hardware flow control is enabled and the CTS line says that the
/// remote device is not ready to receive data, the UART hardware will
/// automatically stop sending data.
///
/// When the flow control is handled by the #hal_UartGetCts, it is called
/// software flow control. The software flow control can be used in parallel to
/// the hardware flow control. Please refer to previous chapters for details
/// about @link #HAL_UART_AFC_MODE_T hardware flow control @endlink.
///
/// @param id Identifier of the UART for which the function is called.
/// @returns Value of the CTS line : \c TRUE if the remote device is ready to
/// receive data, \c FALSE otherwise.
// ============================================================================
PUBLIC BOOL hal_UartGetCts(HAL_UART_ID_T id);


// ============================================================================
// hal_UartIrqSetHandler
// ----------------------------------------------------------------------------
/// Set the user handler called when an Irq is triggered for the
/// defined UART.
/// @param id Identifier of the UART for which the function is called.
/// @param handler User function called in case of an interrupt on this UART
/// occurs.
// ============================================================================
PUBLIC VOID hal_UartIrqSetHandler(HAL_UART_ID_T id, HAL_UART_IRQ_HANDLER_T handler);


// ============================================================================
// hal_UartIrqSetMask
// ----------------------------------------------------------------------------
/// Set the IRQ mask for the specified uart
/// @param id Identifier of the UART for which the function is called.
/// @param mask The mask to apply
// ============================================================================
PUBLIC VOID hal_UartIrqSetMask(HAL_UART_ID_T id, HAL_UART_IRQ_STATUS_T mask);


// ============================================================================
// hal_UartIrqGetMask
// ----------------------------------------------------------------------------
/// Get the IRQ mask set for an UART
/// @param id Identifier of the UART for which the function is called.
/// @return The Irq mask of this uart
// ============================================================================
PUBLIC HAL_UART_IRQ_STATUS_T hal_UartIrqGetMask(HAL_UART_ID_T id);


// ============================================================================
// hal_UartForcePinsLow
// ----------------------------------------------------------------------------
/// This function force all output pins of the UART to low. This can be
/// called for any UART it will only change the state of the pins actually
/// configured in UART mode (IO config).
///
/// This function must only be called when the UART is closed.
///
/// @param id Identifier of the UART for which the function is called.
// ============================================================================
PUBLIC VOID hal_UartForcePinsLow(HAL_UART_ID_T id);

/// @} --> End of uart group

  </cjoker>
</archive>
